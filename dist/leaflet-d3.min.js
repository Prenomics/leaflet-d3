/*! @asymmetrik/leaflet-d3 - 4.4.0 - Copyright (c) 2007-2019 Asymmetrik Ltd, a Maryland Corporation + */
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(require("d3-hexbin"),require("d3-selection"),require("d3-dispatch"),require("d3-scale"),require("d3-array"),require("leaflet")):"function"==typeof define&&define.amd?define(["d3-hexbin","d3-selection","d3-dispatch","d3-scale","d3-array","leaflet"],n):n((t=t||self).d3.hexbin,t.d3Selection,t.d3Dispatch,t.d3Scale,t.d3Array)}(this,function(n,l,e,i,o){"use strict";
/**
	 * L is defined by the Leaflet library, see git://github.com/Leaflet/Leaflet.git for documentation
	 * We extend L.SVG to take advantage of built-in zoom animations.
	 */L.HexbinLayer=L.SVG.extend({includes:L.Evented||L.Mixin.Events,
/**
		 * Default options
		 */
options:{radius:12,opacity:.6,duration:200,scale:"linear",colorScaleExtent:[1,void 0],radiusScaleExtent:[1,void 0],colorDomain:null,radiusDomain:null,colorRange:["#f7fbff","#08306b"],radiusRange:[4,12],pointerEvents:"all"},
/**
		 * Standard Leaflet initialize function, accepting an options argument provided by the
		 * user when they create the layer
		 * @param options Options object where the options override the defaults
		 */
initialize:function(t){L.setOptions(this,t),
// Set up the various overrideable functions
this._fn={lng:function(t){return t[0]},lat:function(t){return t[1]},colorValue:function(t){return t.length},radiusValue:function(t){return Number.MAX_VALUE},fill:function(t){var n="log"===this.options.scale?Math.log2(this._fn.colorValue(t)):this._fn.colorValue(t);return null!=n?this._scale.color(n):"none"}},
// Set up the customizable scale
this._scale={color:i.scaleLinear(),radius:i.scaleLinear()},
// Set up the Dispatcher for managing events and callbacks
this._dispatch=e.dispatch("mouseover","mouseout","click"),
// Set up the default hover handler
this._hoverHandler=L.HexbinHoverHandler.none(),
// Create the hex layout
this._hexLayout=n.hexbin().radius(this.options.radius).x(function(t){return t.point[0]}).y(function(t){return t.point[1]}),
// Initialize the data array to be empty
this._data=[],this._scale.color.range(this.options.colorRange).clamp(!0),this._scale.radius.range(this.options.radiusRange).clamp(!0)},
/**
		 * Callback made by Leaflet when the layer is added to the map
		 * @param map Reference to the map to which this layer has been added
		 */
onAdd:function(t){L.SVG.prototype.onAdd.call(this),
// Redraw on moveend
(
// Store a reference to the map for later use
this._map=t).on({moveend:this.redraw},this),
// Initial draw
this.redraw()},
/**
		 * Callback made by Leaflet when the layer is removed from the map
		 * @param map Reference to the map from which this layer is being removed
		 */
onRemove:function(t){L.SVG.prototype.onRemove.call(this),
// Destroy the svg container
this._destroyContainer(),
// Remove events
t.off({moveend:this.redraw},this),this._map=null,l.select("g.hexbin").remove()},
/**
		 * Create the SVG container for the hexbins
		 * @private
		 */
_initContainer:function(){L.SVG.prototype._initContainer.call(this),this._d3Container=l.select(this._container).select("g")},
/**
		 * Clean up the svg container
		 * @private
		 */
_destroyContainer:function(){
// Don't do anything
},
/**
		 * (Re)draws the hexbins data on the container
		 * @private
		 */
redraw:function(){var t,n,e,i=this;i._map&&(t=i._data.map(function(t){var n=i._fn.lng(t),e=i._fn.lat(t);return{o:t,point:i._project([n,e]),intensity:t[2]}}),e=(n=this._d3Container.selectAll("g.hexbin").data([this._map.getZoom()],function(t){return t})).enter().append("g").attr("class",function(t){return"hexbin zoom-"+t}).merge(n),
// exit
n.exit().remove(),
// add the hexagons to the select
this._createHexagons(e,t));
// Generate the mapped version of the data
},_createHexagons:function(t,n){var e=this,i=e._map.getBounds(),o=e._map.getSize(),i=i.pad(2*e.options.radius/Math.max(o.x,o.y)),a=e._hexLayout(n),r=e._getExtent(a,e._fn.colorValue,e.options.colorScaleExtent),s=e._getExtent(a,e._fn.radiusValue,e.options.radiusScaleExtent),l=this.options.colorDomain;
// Create the bins using the hexbin layout
// Generate the map bounds (to be used to filter the hexes to what is visible)
null==l&&(l=e._linearlySpace(r[0],r[1],e._scale.color.range().length));var u=this.options.radiusDomain||s;
// Set the scale domains
e._scale.color.domain(l),e._scale.radius.domain(u),
/*
			 * Join
			 *    Join the Hexagons to the data
			 *    Use a deterministic id for tracking bins based on position
			 */
a=a.filter(function(t){return i.contains(e._map.layerPointToLatLng(L.point(t.x,t.y)))});var c=t.selectAll("g.hexbin-container").data(a,function(t){return t.x+":"+t.y});
/*
			 * Update
			 *    Set the fill and opacity on a transition
			 *    opacity is re-applied in case the enter transition was cancelled
			 *    the path is applied as well to resize the bins
			 */c.select("path.hexbin-hexagon").transition().duration(e.options.duration).attr("fill",e._fn.fill.bind(e)).attr("fill-opacity",e.options.opacity).attr("stroke-opacity",e.options.opacity).attr("d",function(t){return e._hexLayout.hexagon(e._scale.radius(e._fn.radiusValue.call(e,t)))});
/*
			 * Enter
			 *    Establish the path, size, fill, and the initial opacity
			 *    Transition to the final opacity and size
			 */
var h=c.enter().append("g").attr("class","hexbin-container");h.append("path").attr("class","hexbin-hexagon").attr("transform",function(t){return"translate("+t.x+","+t.y+")"}).attr("d",function(t){return e._hexLayout.hexagon(e._scale.radius.range()[0])}).attr("fill",e._fn.fill.bind(e)).attr("fill-opacity",.01).attr("stroke-opacity",.01).transition().duration(e.options.duration).attr("fill-opacity",e.options.opacity).attr("stroke-opacity",e.options.opacity).attr("d",function(t){return e._hexLayout.hexagon(e._scale.radius(e._fn.radiusValue.call(e,t)))}),
// Grid enter-update
h.append("path").attr("class","hexbin-grid").attr("transform",function(t){return"translate("+t.x+","+t.y+")"}).attr("d",function(t){return e._hexLayout.hexagon(e.options.radius)}).attr("fill","none").attr("stroke","none").style("pointer-events",e.options.pointerEvents).merge(c.select("path.hexbin-grid")).on("mouseover",function(t,n){e._hoverHandler.mouseover.call(this,e,t,n),e._dispatch.call("mouseover",this,t,n)}).on("mouseout",function(t,n){e._dispatch.call("mouseout",this,t,n),e._hoverHandler.mouseout.call(this,e,t,n)}).on("click",function(t,n){e._dispatch.call("click",this,t,n)});
// Exit
var d=c.exit();d.select("path.hexbin-hexagon").transition().duration(e.options.duration).attr("fill-opacity",0).attr("stroke-opacity",0).attr("d",function(t){return e._hexLayout.hexagon(0)}),d.transition().duration(e.options.duration).remove()},_getExtent:function(t,n,e){
// Determine the extent of the values
var i=o.extent(t,n.bind(this));
// If either's null, initialize them to 0
return null==i[0]&&(i[0]=0),null==i[1]&&(i[1]=0),
// Now apply the optional clipping of the extent
null!=e[0]&&(i[0]=e[0]),null!=e[1]&&(i[1]=e[1]),i},_project:function(t){var n=this._map.latLngToLayerPoint([t[1],t[0]]);return[n.x,n.y]},_getBounds:function(t){if(null==t||t.length<1)return{min:[0,0],max:[0,0]};
// bounds is [[min long, min lat], [max long, max lat]]
var i=[[999,999],[-999,-999]];return t.forEach(function(t){var n=t.point[0],e=t.point[1];i[0][0]=Math.min(i[0][0],n),i[0][1]=Math.min(i[0][1],e),i[1][0]=Math.max(i[1][0],n),i[1][1]=Math.max(i[1][1],e)}),{min:i[0],max:i[1]}},_linearlySpace:function(t,n,e){var i=new Array(e);t=t?"log"===this.options.scale?Math.log2(t):t:0;for(var o=(("log"===this.options.scale?Math.log2(n):n)-t)/Math.max(e-1,1),a=0;a<e;++a)i[a]=t+a*o;return i},
// ------------------------------------
// Public API
// ------------------------------------
radius:function(t){return arguments.length?(this.options.radius=t,this._hexLayout.radius(t),this):this.options.radius},opacity:function(t){return arguments.length?(this.options.opacity=t,this):this.options.opacity},duration:function(t){return arguments.length?(this.options.duration=t,this):this.options.duration},colorScaleExtent:function(t){return arguments.length?(this.options.colorScaleExtent=t,this):this.options.colorScaleExtent},radiusScaleExtent:function(t){return arguments.length?(this.options.radiusScaleExtent=t,this):this.options.radiusScaleExtent},colorRange:function(t){return arguments.length?(this.options.colorRange=t,this._scale.color.range(t),this):this.options.colorRange},radiusRange:function(t){return arguments.length?(this.options.radiusRange=t,this._scale.radius.range(t),this):this.options.radiusRange},colorScale:function(t){return arguments.length?(this._scale.color=t,this):this._scale.color},radiusScale:function(t){return arguments.length?(this._scale.radius=t,this):this._scale.radius},lng:function(t){return arguments.length?(this._fn.lng=t,this):this._fn.lng},lat:function(t){return arguments.length?(this._fn.lat=t,this):this._fn.lat},colorValue:function(t){return arguments.length?(this._fn.colorValue=t,this):this._fn.colorValue},radiusValue:function(t){return arguments.length?(this._fn.radiusValue=t,this):this._fn.radiusValue},fill:function(t){return arguments.length?(this._fn.fill=t,this):this._fn.fill},data:function(t){return arguments.length?(this._data=null!=t?t:[],this.redraw(),this):this._data},
/*
		 * Getter for the event dispatcher
		 */
dispatch:function(){return this._dispatch},hoverHandler:function(t){return arguments.length?(this._hoverHandler=null!=t?t:L.HexbinHoverHandler.none(),this.redraw(),this):this._hoverHandler},
/*
		 * Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
		 */
getLatLngs:function(){var n=this;
// Map the data into an array of latLngs using the configured lat/lng accessors
return this._data.map(function(t){return L.latLng(n.options.lat(t),n.options.lng(t))})},
/*
		 * Get path geometry as GeoJSON
		 */
toGeoJSON:function(){return L.GeoJSON.getFeature(this,{type:"LineString",coordinates:L.GeoJSON.latLngsToCoords(this.getLatLngs(),0)})}}),
// Hover Handlers modify the hexagon and can be combined
L.HexbinHoverHandler={tooltip:function(r){null==(
// merge options with defaults
r=r||{}).tooltipContent&&(r.tooltipContent=function(t){var n=t.reduce(function(t,n){return t+=n.intensity},0);return r.transformation&&(n=r.transformation(n)),n});
// Generate the tooltip
var s=l.select(".map.leaflet-container").append("div").attr("class","hexbin-tooltip").style("z-index",9999999).style("pointer-events","none").style("visibility","hidden").style("position","fixed");
// return the handler instance
return s.append("div").attr("class","tooltip-content"),{mouseover:function(t,n){var e,i,o=l.mouse(this),a=null;null!=s._groups&&0<s._groups.length&&0<s._groups[0].length&&(a=s._groups[0][0]),a&&(s.style("visibility","visible").html(r.tooltipContent(n,t)),e=a.clientHeight,i=a.clientWidth,s.style("top",l.event.clientY-o[1]-e-16+"px").style("left",l.event.clientX-o[0]-i/2+"px"))},mouseout:function(t,n){s.style("visibility","hidden").html()}}},resizeFill:function(){
// return the handler instance
return{mouseover:function(n,t){l.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(t){return n._hexLayout.hexagon(n.options.radius)})},mouseout:function(n,t){l.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(t){return n._hexLayout.hexagon(n._scale.radius(n._fn.radiusValue.call(n,t)))})}}},resizeScale:function(e){
// return the handler instance
// merge options with defaults
return null==(e=e||{}).radiusScale&&(e.radiusScale=.5),{mouseover:function(n,t){l.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(t){return n._hexLayout.hexagon(n._scale.radius.range()[1]*(1+e.radiusScale))})},mouseout:function(n,t){l.select(this.parentNode).select("path.hexbin-hexagon").attr("d",function(t){return n._hexLayout.hexagon(n._scale.radius(n._fn.radiusValue.call(n,t)))})}}},compound:function(t){return null==(t=t||{}).handlers&&(t.handlers=[L.HexbinHoverHandler.none()]),{mouseover:function(n,e){var i=this;t.handlers.forEach(function(t){t.mouseover.call(i,n,e)})},mouseout:function(n,e){var i=this;t.handlers.forEach(function(t){t.mouseout.call(i,n,e)})}}},none:function(){return{mouseover:function(){},mouseout:function(){}}}},L.hexbinLayer=function(t){return new L.HexbinLayer(t)}});
//# sourceMappingURL=leaflet-d3.js.map